--- drw.c
+++ drw.c
@@ -15,7 +15,6 @@ static const unsigned char utfbyte[UTF_SIZ + 1] = {0x80,    0, 0xC0, 0xE0, 0xF0}
 static const unsigned char utfmask[UTF_SIZ + 1] = {0xC0, 0x80, 0xE0, 0xF0, 0xF8};
 static const long utfmin[UTF_SIZ + 1] = {       0,    0,  0x80,  0x800,  0x10000};
 static const long utfmax[UTF_SIZ + 1] = {0x10FFFF, 0x7F, 0x7FF, 0xFFFF, 0x10FFFF};
-Clr transcheme[3];
 
 static long
 utf8decodebyte(const char c, size_t *i)
@@ -201,8 +200,8 @@ drw_clr_create(Drw *drw, Clr *dest, const char *clrname)
 		return;
 
 	if (!XftColorAllocName(drw->dpy, DefaultVisual(drw->dpy, drw->screen),
-						   DefaultColormap(drw->dpy, drw->screen),
-						   clrname, dest))
+	                       DefaultColormap(drw->dpy, drw->screen),
+	                       clrname, dest))
 		die("error, cannot allocate color '%s'", clrname);
 }
 
@@ -237,15 +236,6 @@ drw_setscheme(Drw *drw, Clr *scm)
 		drw->scheme = scm;
 }
 
-void
-drw_settrans(Drw *drw, Clr *psc, Clr *nsc)
-{
-	if (drw) {
-		transcheme[0] = psc[ColBg]; transcheme[1] = nsc[ColBg]; transcheme[2] = psc[ColBorder];
-		drw->scheme = transcheme;
-	}
-}
-
 void
 drw_rect(Drw *drw, int x, int y, unsigned int w, unsigned int h, int filled, int invert)
 {
@@ -285,8 +275,8 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
 		XSetForeground(drw->dpy, drw->gc, drw->scheme[invert ? ColFg : ColBg].pixel);
 		XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
 		d = XftDrawCreate(drw->dpy, drw->drawable,
-						  DefaultVisual(drw->dpy, drw->screen),
-						  DefaultColormap(drw->dpy, drw->screen));
+		                  DefaultVisual(drw->dpy, drw->screen),
+		                  DefaultColormap(drw->dpy, drw->screen));
 		x += lpad;
 		w -= lpad;
 	}
@@ -333,7 +323,7 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
 				if (render) {
 					ty = y + (h - usedfont->h) / 2 + usedfont->xfont->ascent;
 					XftDrawStringUtf8(d, &drw->scheme[invert ? ColBg : ColFg],
-									  usedfont->xfont, x, ty, (XftChar8 *)buf, len);
+					                  usedfont->xfont, x, ty, (XftChar8 *)buf, len);
 				}
 				x += ew;
 				w -= ew;
@@ -389,37 +379,6 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
 	return x + (render ? w : 0);
 }
 
-void
-drw_arrow(Drw *drw, int x, int y, unsigned int w, unsigned int h, int direction, int slash)
-{
-	if (!drw || !drw->scheme)
-		return;
-
-	/* direction=1 draws right arrow */
-	x = direction ? x : x + w;
-	w = direction ? w : -w;
-	/* slash=1 draws slash instead of arrow */
-	unsigned int hh = slash ? (direction ? 0 : h) : h/2;
-
-	XPoint points[] = {
-		{x    , y      },
-		{x + w, y + hh },
-		{x    , y + h  },
-	};
-
-	XPoint bg[] = {
-		{x    , y    },
-		{x + w, y    },
-		{x + w, y + h},
-		{x    , y + h},
-	};
-
-	XSetForeground(drw->dpy, drw->gc, drw->scheme[ColBg].pixel);
-	XFillPolygon(drw->dpy, drw->drawable, drw->gc, bg, 4, Convex, CoordModeOrigin);
-	XSetForeground(drw->dpy, drw->gc, drw->scheme[ColFg].pixel);
-	XFillPolygon(drw->dpy, drw->drawable, drw->gc, points, 3, Nonconvex, CoordModeOrigin);
-}
-
 void
 drw_map(Drw *drw, Window win, int x, int y, unsigned int w, unsigned int h)
 {
